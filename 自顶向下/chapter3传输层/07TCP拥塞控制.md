# TCP拥塞控制
TCP必须采用端到端拥塞控制而不是网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。

TCP采用的方法是让每个发送方感知网络的拥塞程序限制它能向连接发送流量的速率。但这种方法提出了三个问题：
  - 第一：TCP发送方如何限制它向连接发送流量的速率？
  - 第二：TCP发送方如何感知从它到目的地之间的路径上存在拥塞？
  - 第三：TCP发送方感知到拥塞后，采用何种算法改变发送速率？

---
问题一的解决方法：

前面说过,TCP连接的每一端都是由一个接收缓存、发送缓存，socket，和一些变量(cwnd，rwnd，序号，确认号等...)组成。
  - cwnd(拥塞窗口)：TCP让允许在发送方的TCP拥塞机制跟踪一个cwnd变量，这个变量限制TCP发送方能像网络中发送流量的速率。
  - rwnd(接收窗口)：指示了对方的接收缓存区大小，用于流量控制。
  - 联合控制：TCP发送方的发送速率 <= min{rwnd,cwnd}。 
  - 接收缓存、发送缓存：指示了自己可以剩余的接收空间和发送空间。

---
问题二的解决方法：

前提：假设TCP接收方接收缓存够大，也就是忽略发送方接收窗口对发送方速率的限制。此时仅关注拥塞控制(和流量控制形成对比)

三大原则
  - 超时、3个冗余ACK指示网络发生了拥塞。拥塞时应当降低TCP发送方发送速率，也就是减小cwnd。
    - 超时：拥塞
    - 冗余ACK：轻微拥塞
  - 对先前未确认报文段的确认到达时，能够增加发送方的发送速率，也就是增加cwnd。
  - 带宽探测。如果给定ACK源到目的路径无拥塞，增加速率。如果有拥塞，减小速率。

说明：我们使用超时和3个冗余ACK指示发生丢包事件。尽管TCP报文段有可能是自身出错被丢弃的(小概率事件)，但总体方向上使用这两种情况指示丢包时间是准确的。

---
问题三的解决：TCP拥塞控制算法

# TCP拥塞控制算法
TCP拥塞算法主要包括三个部分
  - 慢启动
  - 拥塞避免
  - 快速恢复

## 慢启动
慢：初始发送速率慢，但增长速率快。

一条TCP连接开始时，cwnd初始值设置为一个较小的MSS。
  ```
  第一次发送: cwnd(send_rate) = MSS  -> 收到ACK：cwnd(send_rate) = 2MSS
  第二次发送：cwnd(send_rate) = 2MSS  -> 收到ACK：cwnd(send_rate) = 4MSS
  ...
  ```

说明：慢启动阶段的 '慢' 指的是TCP发送速率起始慢，但发送速率是以指数倍增长的。
  
何时结束慢启动？
  - 情况1(超时)

  ``` 
  原因：发生超时，假设此时cwnd = k MSS

  动作:
    结束慢启动 ->
    ssthresh = k/2 MSS(ssthresh是慢启动阈值标记) ->
    cwnd = 1 MSS ->
    重新开始慢启动 ->  
    over
  ```
  - 情况2(达到阈值)

  ```
  原因：cwnd到达慢启动阈值。假设某个时刻，cwnd = k/2 MSS，ssthresh = k/2 MSS

  动作：
    结束慢启动 ->
    进入拥塞避免状态 ->
    over  
  ```

  - 情况3(冗余ACK)

  ```
  原因：检测到3个冗余AC，也就是收到了四个对同一报文段的确认，(1个初始ACK和3个冗余ACK)

  动作：
    结束慢启动 ->
    执行快速重传 ->
    进入快速恢复状态 ->
    over
  ```

## 拥塞避免
每到达一个ACK，cwnd+1 MSS。

例如：
  ```
  假设开始时：
    cwnd = MSS = 8B
    ssthresh = 0B

  开始发送：
    慢启动阶段：
      第一次：发送 cwnd(send_rate) = 8B -> 收到ACK cwnd = 16B
      第二次：发送 cwnd(send_rate) = 16B -> 收到ACK cwnd = 32B
      第三次：发送 cwnd(send_rate) = 32B -> 发生丢失 -> 结束慢启动、ssthresh = k/2 = 16B、cwnd = 1MSS = 8B、重新开始慢启动
    新的慢启动阶段：
      第一次：发送 cwnd(send_rate) = 8B -> 收到ACK cwnd = 16B
      第二次：发送 cwnd(send_rate) = 16B -> 达到阈值 -> 结束慢启动、进入拥塞避免状态
    拥塞避免状态：
      第一次：发送 cwnd(send_rate) = 16B -> 收到ACK cwnd = 17B
      第二次：发送 cwnd(send_rate) = 17B -> 收到ACK cwnd = 18B
      ...
  ```

何时结束拥塞避免？
  - 情况1(超时)

  ```
  原因：发生超时，假设此时cwnd = k MSS

  动作：
    结束拥塞避免 ->
    ssthresh = k/2 MSS ->
    cwnd = 1 MSS ->
    进入慢启动阶段 ->
    over
  ```

  - 情况2(冗余ACK)

  ```
  原因：检测到3个冗余ACK，假设此时cwnd = k MSS

  动作：
    结束拥塞避免 ->
    执行快速重传 ->
    进入快速恢复阶段 ->
    over
  ```

## 快速恢复
快速恢复阶段对收到的每个冗余ACK，cwnd增加1个MSS。

``` 
原因：慢启动或拥塞避免阶段收到3个冗余ACK。假设此时cwnd = k MSS

动作：
  cwnd = (k/2)+3 ->
  进入拥塞避免 ->
  over

注意：如果在快速恢复阶段出现了丢包事件(超时或3个冗余ACK)
    cwnd = 1MSS ->
    ssthresh = k/2 MSS ->
    进入慢启动阶段 ->
    over
```

## 拥塞控制算法回顾
前提：假定忽略一条TCP连接开始时初始的慢启动阶段，假定丢包都是由3个冗余ACK指示，而不是超时指示

TCP的拥塞控制是：每个RTT内cwnd线性增加1MSS(加性增)，然后出现3个冗余ACK时cwnd减半(乘性减)。因此TCP拥塞控制常被称为加性增、乘性减的拥塞控制方式(AIMD)。


# 公平性  
TCP趋于在竞争的多条连接中提供对一段瓶颈链路带宽的平等共享。

## 公平性和UDP
TCP通过拥塞控制窗口来控制应用程序的传输速率，但UDP没有内置的拥塞控制。对TCP来说，运行在UDP上的多媒体应用是不公平的，因为它们不与其他连接合作，也不适时调整速率，并且如果在一条链路中同时有TCP和UDP流量，UDP源可能压制TCP。

## 公平性和TCP并行连接
假设我们能够控制UDP具有公平的行为，公平性问题也没有完全解决。因为我们无法阻止TCP的应用使用多条并行连接，例如：
  ``` 
  假设开始时：
    链路带宽为R，9个c/s模式的应用，每个应用使用一条TCP连接
    则每个应用获得R/9的速率

  t时刻：
    增加了一个应用，这个应用使用11条TCP并行连接
    则原来的应用各自获得1/20的速率
    新应用获得11/20的速率
  ```
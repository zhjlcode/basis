### 特殊用途语言特性
三种函数相关的语言特性：
  - 默认实参
  - 内联函数
  - constexpr函数


### 默认实参
在函数的多次调用中被赋予相同值，我们把这个反复出现的值称为函数的默认实参。

调用含有默认实参的函数，可以包含该实参，也可以省略该实参。

注意：一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

---
*调用*含有默认实参的函数：
``` cpp
//我们适用string对象表示窗口的高、宽和背景字符并为它们设置默认值。但同时我们也允许用户自定义这几个参数
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80,char background = ' ');

string window;
window  = screen();//等价于screen(24,80,' ');
window  = screen(66);//等价于screen(66,80,' ');
window  = screen(66,256);//等价于screen(66,256,' ');
window  = screen(66,256,'#');//等价于screen(66,256,'#');

//说明：调用函数时传入的实参只能按顺序覆盖默认实参
```

---
默认实参*声明*：

对于函数的声明来说，通常将声明放在头文件，并且只声明一次。定义放在对应的头文件。

通常，应该在函数声明中指定默认实参，并将声明放在合适的头文件中。

注意：在给定的作用域中一个形参只能被赋予一次默认值。也就是说函数的后续声明只能为之前那些没有默认值的形参添加形参，不能修改已经有默认值的形参。
``` cpp
string scren(sz , sz , char' ');//表示宽度、高度没有默认值，背景字符为一个空格

string screen(sz , sz , char'*');//错误：不能修改默认值
string sreen(sz = 24,sz = 80,char);//正确，添加实参
```

---
局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。
``` cpp
sz wd = 80;
char def  = ' ';
sz ht();
string screen(sz = ht(),sz = wd,char = def);
//用作函数实参的名字在函数声明所在的作用域内解析(确定参数的内存地址)，这些名字的求值过程(根据地址从参数的内存空间中取出值)发生在函数调用时。例如下面的代码。

string window{screen()};//调用了screen(ht(),wd,' ')

void fun()
{
  def = '*';//def全局的def
  sz wd;//而wd是函数fun内定义的局部变量，
  window = screen();//调用screen(he(),wd,'*')
  

  //在函数声明时就完成了解析，可以认为是确定了三个参数的内存地址。执行函数时，CPU会去找全局的wd、he()、def的内存空间。fun()里面定义的wd跟全局的wd不在一片内存空间中

}
```

### 内联函数
在chap/04函数重载/const_cast和函数重载中，我们通过函数实现了比较两个string对象的size，并且返回size较小的string对象的引用。把这种小规模操作定义为函数有好有坏。
好处：
  - 增加了代码的复用性，函数可以被其他应用反复利用
  - 函数可以确保行为的同一
  - 等等...

缺点：开销大，调用函数一般比使用等价表达式求值慢一些。因为调用函数包含一系列操作：保存断点、保存寄存器、程序转向新位置继续执行并在返回时恢复现场等。

解决方法：将函数指定为内联函数可以避免函数调用的开销。例如:
``` cpp
//格式：inline 返回类型 函数名(参数列表){...}
inline const string& compare(const string &s1,const string &s2)
{
  //传入const string&对象时
  retrun s1.size() <= s2.size() ? s1 : s2; 
}

//调用函数
cout << compare(s1,s2) << endl;
//在编译过程中函数会被展开成以下形式，从而消除了函数的运行时开销
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```

注意：内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

适用场景：内联机制适用于优化规模较小、流程直接。频繁调用的函数。很多编译器都不支持内联递归这种流程复杂的函数。

### constexpr函数
constexpr函数是指能用于常量表达式的函数。

定义constexpr函数的方法与其他函数类似，不过要遵守几项约定。
  - 函数的返回类型及所有形参的类型都必须是字面值类型
  - 函数体中必须有且只有一条返回语句，并且返回值是常量或者常量表达式。

``` cpp
constexpr int new_sz() {return 42;}//constexpr函数
constexpr int foo = new_sz();//正确：foo的数据类型和初始值都是常量，所以foo是一个常量表达式

//编译器可以在编译时验证new_sz()返回的是常量表达式。所以可以用new_sz()初始化constexpr类型的变量foo。
```

执行constexpr变量的初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。

---
constexpr函数不一定返回常量表达式，例如：
``` cpp
//如果传入的参数如果是常量表达式，下面的函数返回常量表达式。如果传入的参数不是常量表达式，下面的函数返回的是非常量表达式。
constexpr int f1(int i){return 10*i;}

int main(void)
{
  int num{10};
  constexpr int v{10};
  
  constexpr int exp1 = f1(v);//正确：返回的是常量表达式
  constexpr int exp2 = f1(num);//错误：constexpr变量只能并且必须使用常量表达式初始化，这里返回的是非常量表达式，编译器会发出错误信息。
}
```

### 内联函数和constexpr函数的定义位置
一般来说：
  - 头文件只能放声明，不能写定义。避免重复定义。
  - 定义写在对应的源文件。

但内联函数和constexpr函数除外，内联函数和constexpr函数通常定义在头文件中。和其它函数不同，内联函数和constexpr函数可以在程序多次定义，因为编译器如果要想展开函数必须要有定义。它们多个定义必须完全一致。
``` cpp
/*
如果有一个内联函数compare，返回两个整数之间的较小值。如果有四个源文件t1.cpp、t2.cpp、t3.cpp和main.cpp都需要使用到这个函数，有两种方法。
  方法1：在每个源文件中都写上这个内联函数的定义。但这样太麻烦，复用性也不高，并且如果一个源文件的内联函数的定义写错了，会产生编译错误
  方法2：在一个头文件写上这个内联函数的定义，要使用这个内联函数的源文件只需要包含这个头文件即可。
*/
inline int compare(int i,int j) {return i <= j ? i : j;}
```